# 函数类
特别的！本文中所有加粗的变量，都是为了传引用，为了得到函数的返回值设计的
每个函数完成后，可以**在开头的多选框标注已经完成**，方便知晓进度！！！！
用如下格式即可
- [x] 已完成
- [ ] 未完成 
## 主信息类型
- [ ] 需要创建一个物品信息struct

## 输入输出函数
### csv输入输出函数
+ 包名：`自己起一个`
- [ ] csv输入函数
  + 函数原型read_csv(path,**index**,**values**)`
  + path是路径，index是一维数组，values是二位数组，分别对应每一条记录。
  + 功能: 输入csv文件的相对路径，然后将csv文件的第一行标题数据依次返回到index；数据值以二维数组组织到values中，其中的每个一维数组为“横着的”，即一条完整的记录作为一个一维数组，而非一列数组组织称一维数组。
- [ ] csv输出函数
  + 函数原型write_csv(path,index,values)
  + 即上方函数的反函数。
### 时间戳生成，转换函数
+ 包名：`time_base64.csp`
- [x] get_local_timestamp()
    + 获取本地时间的base64时间戳
- [x] get_utc_timestamp()
    + 获取utc时间的base64时间戳
- [x] timestamp2string(stamo)
    + 将时间戳转换为读得懂的字符串。
- [x] from_timestamp(t)



### 同级别移动物品

+ 包名：`Item_movement.csp`

- [ ] write_change_statement(id, to_place, commiter)

  + id 是物品ID， to_place是去向
  + from_place/requester可以通过id查出
  + req_time 通过get_local_timestamp()或get_utc_timestamp()完成

  + 写变动表,把内容填上去
- [ ] modify_state(id)
  + 修改状态，需要注意需要保存原有状态
  + 通过id改变signal
  + 记住先write_change_statement再modify_state（顺序很重要）

- [ ] delete_change_statement(id)

  + 移除变动表,就删数据表的内容
  + 通过id反查变动地点表，然后删除字段
  + 建议先add_log，再modify_item_list_information1或modify_item_list_information2，再delete_change_statement

- [ ] modify_item_list_information1(id)

  + 修改物品表信息,修改信息，改地址
  + 通过id反查
  + 恢复signal(signal)，改变地址(to_place)，即可
  + 建议先add_log，再modify_item_list_information1，再delete_change_statement

- [ ] add_log(id)

  + 添加日志,自动生成
  + 通过id查询变动地点表
  + 通过查询信息自动化生成string，并生成日志信息
  + signal是固定的，，
  + 建议先add_log，再modify_item_list_information1或modify_item_list_information2，再delete_change_statement
  + 这个可以分成两部分写，一个是同意，一个是驳回

- [ ] rejection_of_demand(id)

  + 驳回需求,删除变动表(复用)，恢复原来的记录
  + 建议先add_log，再modify_item_list_information2，再delete_change_statement
  + 这个把三个函数包起来
  + <font color=red>直接调用这个包即可</font>

- [ ] modify_item_list_information2(id)

  + 修改物品表信息,修改信息，改地址
  + 通过id反查
  + 恢复signal(signal)，地址(from_place)*其实可以不用修改*，即可
  + 建议先add_log，再modify_item_list_information2，再delete_change_statement

- [ ] acceptance_of_demand(id)

  + 建议先add_log，再modify_item_list_information1，再delete_change_statement
  + <font color=red>直接调用这个包即可</font>

- [ ] start_change(id, to_place, commiter)

  + 记住先write_change_statement再modify_state（顺序很重要）
  + <font color=red>直接调用这个包即可</font>

